package frontend

import frontend.ast._
import frontend.waccErrors.{SemanticError, WaccError}

import java.io.File
import scala.collection.mutable
import scala.io.Source

object validator {

  // Tuple representing a null position in a source file
  private val nullPos: (Int, Int) = (-1, -1)
  // Prefix used for generated WACC code
  val waccPrefix = "wacc_"

  // Function to determine if two types are the same or similar after certain type transformations
  private def sameType(t1: Type, t2: Type): Boolean = {
    // Check if types are equal
    if (t1 == t2) {
      true
    } else (t1, t2) match {
      // Check for specific type transformations that result in different types
      case (ArrayType(StringType()), ArrayType(ArrayType(CharType()))) => false
      case (ArrayType(arrType1), ArrayType(arrType2)) => sameType(arrType1, arrType2)

      case (PairType(StringType(), _), PairType(ArrayType(CharType()), _)) => false
      case (PairType(_, StringType()), PairType(_, ArrayType(CharType()))) => false
      case (PairType(t1l, t1r), PairType(t2l, t2r)) => sameType(t1l, t2l) && sameType(t1r, t2r)

      case (PairType(_, _), Pair()) => true
      case (Pair(), PairType(_, _)) => true
      case (StringType(), ArrayType(CharType())) => true
      // Check if either type is of AnyType, which can match any other type
      case _ => t1 == AnyType || t2 == AnyType
    }
  }

  // Add to the errors generated by a WACC file after compilation to be returned to the user
  private def semanticErrorOccurred(reason: String, pos: (Int, Int))(implicit errors: mutable.ListBuffer[WaccError], source: String, waccLines: Array[String], scopePrefix: Option[String]): Unit = {
    errors += SemanticError.genError(reason, pos)
  }

  // Function to check if any expression passed in as an LValue is of or contains the expected type(s)
  private def checkType(expr: LValue)(implicit symTable: mutable.Map[String, Type]): Type = {

    // Helper function to handle operations on pairs (first or second element)
    def pairOperation(value: LValue, isFirst: Boolean): Type = checkType(value) match {
      case Pair() => AnyType
      case PairType(fst, snd) => if (isFirst) fst else snd
      case _ => NoTypeExists
    }

    // Match the LValue expression and return the corresponding type
    expr match {
      // If it's an identifier, get its type from the symbol table
      case Ident(name) => symTable.getOrElse(name, NoTypeExists)
      // If it's an array element, get the type of the array
      case ArrayElem(id, exprs) => removeArrayWrapper(checkType(id: Expr), exprs.length)
      // If it's a pair first element, get the type of the first element
      case PairFst(value) => pairOperation(value, isFirst = true)
      // If it's a pair second element, get the type of the second element
      case PairSnd(value) => pairOperation(value, isFirst = false)
    }
  }

  private def removeArrayWrapper(typ:Type, dimensions:Int)(implicit symTable: mutable.Map[String, Type]): Type = {
    if (dimensions <= 0) {
      typ
    } else {
      typ match {
        case ArrayType(arrTyp) => removeArrayWrapper(arrTyp, dimensions - 1)
        case _ => NoTypeExists
      }
    }

  }


  // Function to check the type of a new pair expression
  private def checkNewPair(exp1: Expr, exp2: Expr)(implicit symTable: mutable.Map[String, Type]): PairType = {

    // Helper function to resolve the type of a pair element
    def resolvePairType(expr: Expr): PairElemType = checkType(expr) match {
      case PairType(_, _) => Pair()(nullPos)
      case pairType: PairElemType => pairType
      case _ => NoTypeExists
    }

    // Get the type of the first and second expressions
    val exp1Type: PairElemType = resolvePairType(exp1)
    val exp2Type: PairElemType = resolvePairType(exp2)

    // Return the PairType with the resolved types of the expressions
    PairType(exp1Type, exp2Type)(null)
  }


  // Function to check the type of an RValue expression
  def checkType(expr: RValue)(implicit symTable: mutable.Map[String, Type], funcTable: List[Func]): Type = expr match {
    // If the expression is an Expr, recursively check its type
    case exp: Expr => checkType(exp)

    // If the expression is a NewPair, check its type using checkNewPair function
    case NewPair(exp1, exp2) =>
      checkNewPair(exp1, exp2)

    // If the expression is a Call, find the corresponding function in the function table and return its type
    case Call(ident, _) => funcTable.find(x => x.ident.name == ident.name) match {
      case Some(value) => value.typ.getOrElse(AnyType)
      case None => NoTypeExists
    }

    // If the expression is PairFst or PairSnd, check the type of the inner expression and return the pair element type
    case PairFst(value) => checkType(value) match {
      case Pair() => AnyType
      case PairType(pairTyp, _) => pairTyp
      case _ => NoTypeExists
    }
    case PairSnd(value) => checkType(value) match {
      case Pair() => AnyType
      case PairType(_, pairTyp) => pairTyp
      case _ => NoTypeExists
    }

    // If the expression is an ArrayLit, check its type using getArrayLitType function
    case ArrayLit(elems) => if (elems.isEmpty) ArrayType(AnyType)(nullPos) else {
      ArrayType(getArrayLitType(elems))(nullPos)
    }
  }


  // Function to determine the type of an array literal based on its elements
  private def getArrayLitType(elems: List[Expr])(implicit symTable: mutable.Map[String, Type]): Type = {
    // If the list of elements is empty, return NoTypeExists as there is no type information
    if (elems.isEmpty) {
      NoTypeExists
    } else {
      // Map each expression to its type using checkType function
      val arrayElementTypes: List[Type] = elems.map(checkType)

      // If the array contains StringType elements, return StringType
      if (arrayElementTypes.contains(StringType()(nullPos))) {
        StringType()(nullPos)
      } else {
        // Otherwise, return the type of the first element
        arrayElementTypes.head
      }
    }
  }


  // Function to check the type of expressions involved in binary or unary operations
  def checkType(expr: Expr)(implicit symTable: mutable.Map[String, Type]): Type = {
    expr match {
      // Arithmetic binary operations return IntType
      case Sub(_, _) | Add(_, _) | Mul(_, _) | Div(_, _) | Mod(_, _) => IntType()(nullPos)

      // Comparison binary operations return BoolType
      case GT(_, _) | GTE(_, _) | LT(_, _) | LTE(_, _) | Eq(_, _) | NEq(_, _) => BoolType()(nullPos)

      // Logical binary operations return BoolType
      case And(_, _) | Or(_, _) => BoolType()(nullPos)

      // Unary operations return IntType or CharType or BoolType depending on the operation
      case Plus(_) => IntType()(nullPos)
      case Not(_) => BoolType()(nullPos)
      case Len(_) | Neg(_) | Ord(_) => IntType()(nullPos)
      case Chr(_) => CharType()(nullPos)

      // Array element access returns the type of the elements inside the array
      case ArrayElem(id, exprs) => removeArrayWrapper(checkType(id: Expr), exprs.length)

      // Literal expressions return their corresponding types
      case BoolLit(_) => BoolType()(nullPos)
      case IntLit(_) => IntType()(nullPos)
      case CharLit(_) => CharType()(nullPos)
      case StrLit(_) => StringType()(nullPos)
      case PairLiter() => PairType(AnyType, AnyType)(nullPos)

      // Identifiers return their type from the symbol table or NoTypeExists if not found
      case Ident(name) => symTable.getOrElse(name, NoTypeExists)

      // Atomic expressions, unary operations, and binary operations are not directly supported and return NoTypeExists
      case _: Atom | _: UnOpp | _: BinOpp => NoTypeExists
    }
  }

  // Creates a new array element
  private def createArrayElem(name: String, idPos: (Int, Int), indexes: List[Expr], exprPos: (Int, Int)): ArrayElem = {
    new ArrayElem(new Ident(name)(idPos), indexes)(exprPos)
  }


  // Function to check the syntactic correctness of expressions representing l-values according to the WACC specification
  private def checkExpr(expr: LValue, varsInScope: mutable.Map[String, String])
                       (implicit errors: mutable.ListBuffer[WaccError],
                        symTable: mutable.Map[String, Type],
                        funcTable: List[Func],
                        source: String,
                        waccLines: Array[String],
                        funcName: Option[String]): LValue = {
    expr match {
      // Identifier: Resolve the identifier and return the corresponding l-value
      case id@Ident(name) =>
        resolveIdentifier(name, varsInScope, id)
      // Array Element: Check array index, then check if the array identifier evaluates to correct type
      case ArrayElem(id, indexes) =>
        checkArrayIndex(indexes, varsInScope) match {
          case Some((err, pos)) => semanticErrorOccurred(err, pos)
          case _ =>
        }
        id match {
          case ArrayElem(_, _) =>
            checkExpr(id: Expr, varsInScope) match {
              case newId: Ident => new ArrayElem(newId, indexes)(expr.pos)
              case _ =>
                semanticErrorOccurred(s"Array identifier evaluates to incorrect type: $id", id.pos)
                expr
            }
          case Ident(name) =>
            symTable.get(varsInScope.getOrElse(name, "")) match {
              case Some(value) => value match {
                case ArrayType(_) => createArrayElem(varsInScope(name), id.pos, indexes, expr.pos)
                case _ =>
                  semanticErrorOccurred(s"Attempting to access array element from non-array identifier: $name", id.pos)
                  expr
              }
              case None =>
                semanticErrorOccurred(s"Identifier not in scope: $name", id.pos)
                expr
            }
        }
      // Pair First: Recursively check the value expression and return PairFst l-value
      case PairFst(value) => new PairFst(checkExpr(value, varsInScope))(expr.pos)
      // Pair Second: Recursively check the value expression and return PairSnd l-value
      case PairSnd(value) => new PairSnd(checkExpr(value, varsInScope))(expr.pos)
    }
  }

  // Function to check the syntactic correctness of array indexes according to the WACC specification
  private def checkArrayIndex(exprs: List[Expr], varsInScope: mutable.Map[String, String])
                             (implicit errors: mutable.ListBuffer[WaccError],
                              symTable: mutable.Map[String, Type],
                              funcTable: List[Func],
                              source: String,
                              waccLines: Array[String],
                              funcName: Option[String]): Option[(String, (Int, Int))] = {
    for (expr <- exprs) {
      // Check each expression in the list of indexes
      val newExpr = checkExpr(expr, varsInScope)
      checkType(newExpr)(symTable) match {
        // If the expression type is Int, continue to the next expression
        case IntType() =>
        // If the expression type is not Int, return an error message with the position
        case _ => return Option("Array Indexes must be of type <int>", expr.pos)
      }
    }
    // If all expressions in the list are of type Int, return None (no errors found)
    None
  }

  // Finds the dimension of an array
  private def getDimension(array:Type): Int = {
    array match {
      case ArrayType(x) => 1 + getDimension(x)
      case _ => 0
    }
  }

  // Function to check the syntactic correctness of an expression in the context of an RValue according to the WACC specification
  private def checkExpr(expr: RValue, varsInScope: mutable.Map[String, String])
                       (implicit errors: mutable.ListBuffer[WaccError],
                        symTable: mutable.Map[String, Type],
                        funcTable: List[Func],
                        source: String,
                        waccLines: Array[String],
                        funcName: Option[String]): RValue = {
    // Function to check if the element of a Pair expression is syntactically correct
    def checkPairElement(exp: Expr): Unit = checkType(exp) match {
      case PairType(_, _) =>
      case _: PairElemType =>
      case _ => semanticErrorOccurred("Invalid data type for element in newpair", exp.pos)
    }

    expr match {
      // If the expression is an Expr, check its syntactic correctness recursively
      case exp: Expr => checkExpr(exp, varsInScope)
      case NewPair(exp1, exp2) =>
        // Check the syntactic correctness of each expression in the NewPair construct
        val newExp1 = checkExpr(exp1, varsInScope)
        val newExp2 = checkExpr(exp2, varsInScope)
        // Check if each expression is syntactically correct for a Pair
        checkPairElement(newExp1)
        checkPairElement(newExp2)
        // Return a new NewPair expression with the corrected expressions
        new NewPair(newExp1, newExp2)(expr.pos)
      case Call(id, params) =>
        // Check the syntactic correctness of each parameter in the function call
        val newParams = params.map(checkExpr(_, varsInScope))
        // Create a new identifier with the WACC prefix for the function name
        val newId = Ident(waccPrefix + id.name)(id.pos)
        // Find the function definition in the function table
        funcTable.find(x => x.ident.name == newId.name) match {
          case Some(funcCalled) =>
            // Check if the number of arguments matches the number of parameters in the function definition
            if (funcCalled.paramList.length != newParams.length) {
              semanticErrorOccurred(s"Call to function ${id.name} has the incorrect number of arguments, expected ${funcCalled.paramList.length}, found ${newParams.length}", expr.pos)
            }
            // Check if the types of arguments match the types of parameters in the function definition
            (funcCalled.paramList zip newParams).foreach({ case (x, y) =>
              if (!sameType(x.typ, checkType(y))) {
                semanticErrorOccurred(s"Argument ${x.ident.name} in the call to function ${id.name} has the incorrect type. Expected ${x.typ}. Received ${checkType(y)}", y.pos)
              }
            })
          case None => semanticErrorOccurred(s"Unrecognised function identifier ${id.name}", id.pos)
        }
        // Return a new Call expression with the corrected parameters
        new Call(newId, newParams)(expr.pos)
      case ArrayLit(elems) =>
        // Check the syntactic correctness of each element in the array literal
        val newElems = elems.map(checkExpr(_, varsInScope))
        // Get the type of the array literal
        val arrayType = getArrayLitType(newElems)
        // Check if each element has the same type as the array literal
        newElems.foreach(x =>
          if (!sameType(arrayType, checkType(x)))
            semanticErrorOccurred("Elements in array literal have different types", expr.pos))
        // Return a new ArrayLit expression with the corrected elements
        new ArrayLit(newElems)(expr.pos)
      case PairFst(value) => new PairFst(checkExpr(value, varsInScope))(expr.pos)
      case PairSnd(value) => new PairSnd(checkExpr(value, varsInScope))(expr.pos)
    }
  }

  // Function to check the syntactic correctness of other expressions according to the WACC specification
  private def checkExpr(expr: Expr, varsInScope: mutable.Map[String, String])
                       (implicit errors: mutable.ListBuffer[WaccError],
                        symTable: mutable.Map[String, Type],
                        funcTable: List[Func],
                        source: String,
                        waccLines: Array[String],
                        funcName: Option[String]): Expr = {
    expr match {
      // If the expression is a binary operation, check its syntactic correctness
      case binOp: BinOpp => checkBinOp(binOp, varsInScope)
      // If the expression is a unary operation, check its syntactic correctness
      case unOp: UnOpp => checkUnOp(unOp, varsInScope)
      // If the expression is an ArrayElem
      case ArrayElem(id, indexes) =>
        // Check the syntactic correctness of the array indexes
        checkArrayIndex(indexes, varsInScope) match {
          case Some((err, pos)) => semanticErrorOccurred(err, pos)
          case _ =>
        }
        // Get the dimension of the array
        val arrDim = getDimension(checkType(checkExpr(id: Expr, varsInScope)))
        // Check if the number of indexes matches the dimension of the array
        if (arrDim < indexes.length && arrDim != 0) {
          semanticErrorOccurred(s"Array dimensions do not match: expected $arrDim , found ${indexes.length}", id.pos)
        }

        id match {
          case ArrayElem(_, _) =>
            checkExpr(id: Expr, varsInScope) match {
              case newId: Ident => new ArrayElem(newId, indexes)(expr.pos)
              case _ =>
                semanticErrorOccurred(s"Array identifier evaluates to the wrong type", id.pos)
                expr
            }
          case Ident(name) =>
            symTable.get(varsInScope.getOrElse(name, "")) match {
              case Some(value) => value match {
                case ArrayType(_) => createArrayElem(varsInScope(name), id.pos, indexes, expr.pos)
                case _ =>
                  semanticErrorOccurred(s"Attempting to access array element from non-array identifier $name", id.pos)
                  expr
              }
              case None =>
                expr
            }
        }
      // If the expression is an identifier, resolve it
      case id@Ident(name) =>
        resolveIdentifier(name, varsInScope, id)
      // For other expressions, return as is
      case _ => expr
    }
  }


  // Resolves an identifier within the given scope, ensuring it is in scope.
  // If the identifier is not found in the scope, a semantic error is recorded.
  private def resolveIdentifier(name: String, varsInScope: mutable.Map[String, String], id: Ident)
                               (implicit errors: mutable.ListBuffer[WaccError],
                                source: String,
                                waccLines: Array[String],
                                funcName: Option[String]): Ident = {
    // Check if the identifier exists in the current scope
    if (!varsInScope.contains(name)) {
      // Record a semantic error if the identifier is not in scope
      semanticErrorOccurred(s"Identifier not in scope: $name", id.pos)
      id // Return the original identifier
    } else {
      // Return a new identifier object with the value from the scope
      new Ident(varsInScope(name))(id.pos)
    }
  }


  // Checks unary operators for syntactic correctness according to the WACC specification.
  private def checkUnOp(expr: UnOpp, varsInScope: mutable.Map[String, String])
                       (implicit errors: mutable.ListBuffer[WaccError],
                        symTable: mutable.Map[String, Type],
                        funcTable: List[Func],
                        source: String,
                        waccLines: Array[String],
                        funcName: Option[String]): UnOpp = {
    // Check the expression inside the unary operator
    val inside = checkExpr(expr.x, varsInScope)

    // Helper functions to check if the expression inside the unary operator has the expected type
    def returnsIntType(op: String): Unit = {
      checkType(inside) match {
        case IntType() => // No error if the type is int
        case _ => semanticErrorOccurred(s"Argument $op is not of type <int>, is type ${checkType(inside)}", inside.pos)
      }
    }

    def returnsCharType(op: String): Unit = {
      checkType(inside) match {
        case CharType() => // No error if the type is char
        case _ => semanticErrorOccurred(s"Argument $op is not of type <char>, is type ${checkType(inside)}", inside.pos)
      }
    }

    def returnsBoolType(op: String): Unit = {
      checkType(inside) match {
        case BoolType() => // No error if the type is bool
        case _ => semanticErrorOccurred(s"Argument $op is not of type <bool>, is type ${checkType(inside)}", inside.pos)
      }
    }

    def returnsSeqType(op: String): Unit = {
      checkType(inside) match {
        case ArrayType(_) => // No error if the type is array
        case StringType() => // No error if the type is string
        case _ => semanticErrorOccurred(s"Argument $op is not of type <string>, is type ${checkType(inside)}", inside.pos)
      }
    }

    // Check each unary operator type and validate its argument type
    expr match {
      case Chr(_) =>
        returnsIntType("chr")
        new Chr(inside)(expr.pos)
      case Len(_) =>
        returnsSeqType("len")
        new Len(inside)(expr.pos)
      case Neg(_) =>
        returnsIntType("neg")
        new Neg(inside)(expr.pos)
      case Not(_) =>
        returnsBoolType("!")
        new Not(inside)(expr.pos)
      case Ord(_) =>
        returnsCharType("ord")
        new Ord(inside)(expr.pos)
      case unOpp: UnOpp =>
        unOpp // Return the original unary operator expression
    }
  }

  // Checks binary operators for syntactic correctness according to the WACC specification.
  private def checkBinOp(expr: BinOpp, varsInScope: mutable.Map[String, String])
                        (implicit errors: mutable.ListBuffer[WaccError],
                         symTable: mutable.Map[String, Type],
                         funcTable: List[Func],
                         source: String,
                         waccLines: Array[String],
                         funcName: Option[String]): BinOpp = {
    // Check the expressions on both sides of the binary operator
    val newX = checkExpr(expr.x, varsInScope)
    val newY = checkExpr(expr.y, varsInScope)

    // Helper functions to check if the expressions on both sides have the expected types for each binary operator
    def returnsIntType(op: String): Unit = {
      // Check if the left expression is of type int
      checkType(newX) match {
        case IntType() => // No error if the type is int
        case NoTypeExists => // No error if the type is not available
        case _ => semanticErrorOccurred(s"Left expression in $op is not of type <int>, is ${checkType(newX)} instead", newX.pos)
      }
      // Check if the right expression is of type int
      checkType(newY) match {
        case IntType() => // No error if the type is int
        case NoTypeExists => // No error if the type is not available
        case _ => semanticErrorOccurred(s"Right expression in $op is not of type <int>, is ${checkType(newY)} instead", newY.pos)
      }
    }

    def returnsBoolType(op: String): Unit = {
      // Check if the left expression is of type bool
      checkType(newX) match {
        case BoolType() => // No error if the type is bool
        case NoTypeExists => // No error if the type is not available
        case _ => semanticErrorOccurred(s"Left expression in $op is not of type <bool>, is ${checkType(newX)} instead", newX.pos)
      }
      // Check if the right expression is of type bool
      checkType(newY) match {
        case BoolType() => // No error if the type is bool
        case NoTypeExists => // No error if the type is not available
        case _ => semanticErrorOccurred(s"Right expression in $op is not of type <bool>, is ${checkType(newY)} instead", newY.pos)
      }
    }

    def returnsIntOrCharType(op: String)(implicit funcName: Option[String]): Unit = {
      // Check if the left expression is of type int or char
      val exp1Typ = checkType(newX)
      exp1Typ match {
        case IntType() => // No error if the type is int
        case CharType() => // No error if the type is char
        case NoTypeExists => // No error if the type is not available
        case _ => semanticErrorOccurred(s"Left expression in $op is not of type <int> nor type <char>, is ${checkType(newX)} instead", newX.pos)
      }
      // Check if the right expression is of type int or char
      val exp2Typ = checkType(newY)
      exp2Typ match {
        case IntType() => // No error if the type is int
        case CharType() => // No error if the type is char
        case NoTypeExists => // No error if the type is not available
        case _ => semanticErrorOccurred(s"Right expression in $op is not of type <int> nor type <char>, is ${checkType(newY)} instead", newY.pos)
      }
      // Check if both sides have the same type
      if (!sameType(exp1Typ, exp2Typ)) {
        semanticErrorOccurred(s"Two sides of $op have different types, left is of type $exp1Typ, right is of type $exp2Typ", expr.pos)
      }
    }

    def returnsSameType(op: String): Unit = {
      // Check if both sides have the same type
      val exp1Typ = checkType(newX)
      val exp2Typ = checkType(newY)
      if (!sameType(exp1Typ, exp2Typ)) {
        semanticErrorOccurred(s"Two sides of $op have different types, left is of type $exp1Typ, right is of type $exp2Typ", expr.pos)
      }
    }

    // Check each binary operator type and validate its argument types
    expr match {
      case Sub(_, _) =>
        returnsIntType("subtraction")
        new Sub(newX, newY)(expr.pos)
      case Add(_, _) =>
        returnsIntType("addition")
        new Add(newX, newY)(expr.pos)
      case Mul(_, _) =>
        returnsIntType("multiplication")
        new Mul(newX, newY)(expr.pos)
      case Div(_, _) =>
        returnsIntType("division")
        new Div(newX, newY)(expr.pos)
      case Mod(_, _) =>
        returnsIntType("modulo")
        new Mod(newX, newY)(expr.pos)
      case GT(_, _) =>
        returnsIntOrCharType("\'>\'")
        new GT(newX, newY)(expr.pos)
      case GTE(_, _) =>
        returnsIntOrCharType("\'>=\'")
        new GTE(newX, newY)(expr.pos)
      case LT(_, _) =>
        returnsIntOrCharType("\'<\'")
        new LT(newX, newY)(expr.pos)
      case LTE(_, _) =>
        returnsIntOrCharType("\'<=\'")
        new LTE(newX, newY)(expr.pos)
      case Eq(_, _) =>
        returnsSameType("\'==\'")
        new Eq(newX, newY)(expr.pos)
      case NEq(_, _) =>
        returnsSameType("\'!=\'")
        new NEq(newX, newY)(expr.pos)
      case And(_, _) =>
        returnsBoolType("and operation")
        new And(newX, newY)(expr.pos)
      case Or(_, _) =>
        returnsBoolType("or operation")
        new Or(newX, newY)(expr.pos)
      case binOpp: BinOpp =>
        binOpp // Return the original binary operator expression
    }
  }

  // Checks a list of statements for syntactic correctness according to the WACC specification.
  private def checkStatements(stats: List[Stat],
                              varsInScope: mutable.Map[String, String],
                              returnType: Type,
                              scopePrefix: String)
                             (implicit errors: mutable.ListBuffer[WaccError],
                              symTable: mutable.Map[String, Type],
                              funcTable: List[Func],
                              source: String,
                              waccLines: Array[String]): List[Stat] = {

    // Local symbol table to keep track of variables declared within the current scope
    var localSymTable: mutable.Map[String, String] = mutable.Map.empty[String, String]
    // Buffer to store the checked statements
    val newStats: mutable.ListBuffer[Stat] = mutable.ListBuffer.empty[Stat]
    // Index to generate unique scope prefixes
    var scopeIndex = 0
    implicit val funcName: Option[String] = Option(scopePrefix)

    /* returns true if the lvalue isn't declared yet */
    def isInferredTypeDef(lVal: LValue): Boolean = {
      lVal match {

        /* if its an identifier then check if its in the parent and child scope maps yet */
        case Ident(name) =>
          !localSymTable.values.exists(_ == name)
        case _ => false
      }
    }

    // Iterate through each statement in the list
    for (stat <- stats) {
      val checkedStat: Stat = stat match {
        case Skip() => stat // No action needed for Skip statement
        case Declaration(idType, id, value) =>
          val newValue = checkExpr(value, varsInScope ++ localSymTable)
          val newIdName = scopePrefix ++ id.name

          // Check for variable redeclaration
          if (localSymTable.contains(id.name)) {
            semanticErrorOccurred(s"Variable named '${id.name}' is already defined", id.pos)
          } else if (!sameType(idType, checkType(newValue)) && checkType(newValue) != NoTypeExists) {
            semanticErrorOccurred(s"Type mismatch in declaration of ${id.name}: expected $idType, found ${checkType(newValue)}", stat.pos)
          }

          // Add the variable to the local symbol table and the global symbol table
          localSymTable = localSymTable.concat(Map(id.name -> newIdName))
          symTable += (newIdName -> idType)
          new Declaration(idType, new Ident(newIdName)(id.pos), newValue)(stat.pos)

        case AssignorInferDecl(lVal, rVal) =>
          val newLVal = checkExpr(lVal, varsInScope ++ localSymTable)
          val newRVal = checkExpr(rVal, varsInScope ++ localSymTable)

          var lType: Type = NoTypeExists
          var rType: Type = NoTypeExists

          lVal match {
            case Ident(name) => {
              if (isInferredTypeDef(newLVal)) {
                val newIdName = scopePrefix ++ name
                localSymTable = localSymTable.concat(Map(name -> newIdName))
                rType = checkType(newRVal)
                lType = rType
                symTable += (newIdName -> lType)
              } else {
                lType = checkType(newLVal)
                rType = checkType(newRVal)
              }
            }
            case _ =>
              lType = checkType(newLVal)
              rType = checkType(newRVal)
          }

          // Check for type mismatch in assignment
          //  !sameType(checkType(lVal), checkType(newRVal)) && checkType(lVal) != NoTypeExists
          if ((lType != rType && rType != lType) || !sameType(lType, rType)) {
            semanticErrorOccurred(s"Type mismatch in assignment: expected $lType, found $rType", stat.pos)
          } else if (lType == AnyType && rType == AnyType) {
            semanticErrorOccurred("Types unclear on both sides of assignment", stat.pos)
          }

          new AssignorInferDecl(newLVal, newRVal)(stat.pos)

        case Read(expr) =>
          val newExpr = checkExpr(expr, varsInScope ++ localSymTable)

          // Check if the variable being read is of type int, char, or string
          checkType(newExpr) match {
            case IntType() =>
            case CharType() =>
            case StringType() =>
            case _ => semanticErrorOccurred(s"Variable attempting read has incorrect type ${checkType(newExpr)}, can only be of type <int>, <char> or <string>", stat.pos)
          }

          new Read(newExpr)(stat.pos)

        case Free(expr) =>
          val newExpr = checkExpr(expr, varsInScope ++ localSymTable)

          // Check if the expression to be freed is of type Pair or Array
          checkType(newExpr) match {
            case PairType(_, _) | ArrayType(_) =>
            case _ => semanticErrorOccurred(s"Only Pair and Array types can be freed, is type ${checkType(newExpr)}", stat.pos)
          }

          new Free(newExpr)(stat.pos)

        case Return(expr) =>
          val newExpr = checkExpr(expr, varsInScope ++ localSymTable)

          // Check for return statement outside of a function or type mismatch in return type
          if (returnType == null) {
            semanticErrorOccurred("Return statement outside of a function is not allowed", stat.pos)
          } else if (!sameType(checkType(newExpr), returnType) && checkType(newExpr) != NoTypeExists) {
            semanticErrorOccurred(s"Type mismatch in Return: expected $returnType, found ${checkType(expr)}", stat.pos)
          }

          new Return(newExpr)(stat.pos)

        case Exit(expr) =>
          val newExpr = checkExpr(expr, varsInScope ++ localSymTable)

          // Check if the exit code is of type int
          checkType(newExpr) match {
            case IntType() =>
            case _ => semanticErrorOccurred(s"Exit code defined is not of type <int>, is type ${checkType(newExpr)}", newExpr.pos)
          }

          new Exit(newExpr)(stat.pos)

        case Print(expr) =>
          new Print(checkExpr(expr, varsInScope ++ localSymTable))(stat.pos)

        case Println(expr) =>
          new Println(checkExpr(expr, varsInScope ++ localSymTable))(stat.pos)

        case If(expr, thenStat, elseStat) =>
          val newExpr = checkExpr(expr, varsInScope ++ localSymTable)

          // Check if the condition for the If statement is of type bool
          checkType(newExpr) match {
            case BoolType() =>
            case NoTypeExists =>
            case _ => semanticErrorOccurred("Condition for If statement is not of type <bool>", expr.pos)
          }

          // Check the statements inside the then and else blocks
          val newThenStat = checkStatements(thenStat, varsInScope ++ localSymTable, returnType, s"$scopePrefix${scopeIndex}if-then-")
          val newElseStat = checkStatements(elseStat, varsInScope ++ localSymTable, returnType, s"$scopePrefix${scopeIndex}if else-")
          scopeIndex += 1
          new If(newExpr, newThenStat, newElseStat)(stat.pos)

        case While(expr, whileBody) =>
          val newExpr = checkExpr(expr, varsInScope ++ localSymTable)

          // Check if the condition for the While statement is of type bool
          checkType(newExpr) match {
            case BoolType() =>
            case NoTypeExists =>
            case _ => semanticErrorOccurred("Condition for While statement is not of type <bool>", expr.pos)
          }

          // Check the statements inside the while loop
          val newBody = checkStatements(whileBody, varsInScope ++ localSymTable, returnType, s"$scopePrefix${scopeIndex}while-")
          scopeIndex += 1
          new While(newExpr, newBody)(stat.pos)

        case Scope(body) =>
          // Check the statements inside the scope
          val newBody = checkStatements(body, varsInScope ++ localSymTable, returnType, s"$scopePrefix%${scopeIndex}scope-")
          scopeIndex += 1
          new Scope(newBody)(stat.pos)
      }
      newStats += checkedStat
    }
    newStats.toList // Return the list of checked statements
  }

  // Helper function to infer return type of a function
  private def inferFuncReturnType(ident: Ident, stats: List[Stat], file: String, varTable: mutable.Map[String, Type], funcTbl: List[Func]): Type = {
    // Initialize inferred return type as NoTypeExists
    var returnType: Type = NoTypeExists

    implicit val fileName: String = file

    // Read file contents
    val fileSource = Source.fromFile(new File(file))
    implicit val fileContents: Array[String] = fileSource.getLines().toArray
    fileSource.close()

    // Initialize symbol table and error buffer
    implicit val symTable: mutable.Map[String, Type] = varTable
    implicit val errors: mutable.ListBuffer[WaccError] = mutable.ListBuffer.empty[WaccError]
    implicit val funcTable: List[Func] = funcTbl
    implicit val funcName: Option[String] = Option(ident.name)

    def translateScopeVar(sym: String): (String, String) = {
      val identIndex = sym.lastIndexOf("-")
      if (identIndex >= 0 && identIndex < sym.length - 1)
        (sym.substring(identIndex + 1), sym)
      else
      ("", "")
    }

    val varsInScope: mutable.Map[String, String] = symTable.map { case (key, _) =>
      translateScopeVar(key)
    }


    // Traverse the statements in reverse order to find the last return statement
    for (stat <- stats.reverse) {
      stat match {
        case Return(expr) =>
          // If a return statement is found, infer the type of the expression
          returnType = checkType(checkExpr(expr, varsInScope))
          // Exit the loop once return statement is found
          return returnType
        case If(_, thenStats, elseStats) =>
          // If statement: recursively infer return type from both branches
          val thenReturnType = inferFuncReturnType(ident, thenStats, file, symTable, funcTable)
          val elseReturnType = inferFuncReturnType(ident, elseStats, file, symTable, funcTable)
          // Update inferred return type based on the most specific common type
          returnType = findCommonType(thenReturnType, elseReturnType)
        case While(_, whileStats) =>
          // While loop: recursively infer return type from the loop body
          returnType = inferFuncReturnType(ident, whileStats, file, symTable, funcTable)
        case _ => // For other statements, continue traversing
      }
    }

    // If no return statement is found, return NoTypeExists
    returnType
  }

  // Helper function to find the most specific common type between two types
  def findCommonType(type1: Type, type2: Type): Type = {
    // Logic to determine the most specific common type
    // For simplicity, let's assume the types are compatible
    type1
  }


  // Checks the semantics of a WACC program, including syntax correctness, type checking, and scoping rules.
  def checkSemantics(inProg: Prog, file: String): (List[WaccError], Prog, mutable.Map[String, Type]) = {
    // Implicit parameters for function and file context
    implicit val funcTable: List[Func] = inProg.funcs.map {
      case x@Func(funcType, id, params, funcStats) =>
        new Func(funcType, Ident(waccPrefix + id.name)(id.pos), params, funcStats)(x.pos)
    }
    implicit val fileName: String = file

    // Read file contents
    val fileSource = Source.fromFile(new File(file))
    implicit val fileContents: Array[String] = fileSource.getLines().toArray
    fileSource.close()

    // Initialize symbol table and error buffer
    implicit val symTable: mutable.Map[String, Type] = mutable.LinkedHashMap[String, Type]()
    implicit val errors: mutable.ListBuffer[WaccError] = mutable.ListBuffer.empty[WaccError]

    // Initialize main scope
    implicit val mainScope: Option[String] = Option.empty

    // Check for duplicated function declarations and arguments
    var tempFuncTable: List[Func] = Nil
    val newFuncs = funcTable.map(x => {
      if (tempFuncTable.exists(y => y.ident.name == x.ident.name)) {
        semanticErrorOccurred(s"Duplicated function declaration: ${x.ident.name.replace(waccPrefix, "")}", x.pos)
      } else {
        tempFuncTable = tempFuncTable :+ x
      }
      var argList: List[Param] = Nil
      x.paramList.foreach(a => if (argList.exists(b => a.ident.name == b.ident.name)) {
        semanticErrorOccurred(s"Duplicated function argument ${a.ident.name.replace(waccPrefix, "")} in function ${x.ident.name.replace(waccPrefix, "")}", a.pos)
      } else {
        argList = argList :+ a
      })
      val funcScopePrefix = s"func-${x.ident.name}-"
      x.paramList.foreach(y => symTable += (funcScopePrefix ++ "param-" ++ y.ident.name) -> y.typ)

      val mBuilder = mutable.Map.newBuilder[String, String]
      mBuilder ++= x.paramList.map(y => y.ident.name -> (funcScopePrefix ++ "param-" ++ y.ident.name))
      val m: mutable.Map[String, String] = mBuilder.result()

      // Check statements within the function scope
      val inferredType: Type = inferFuncReturnType(x.ident, x.stats, file, symTable, funcTable)
      if (x.typ.isEmpty) {
        x.typ = Option(inferredType)
      }
        new Func(x.typ, x.ident, x.paramList,
          checkStatements(x.stats, m, x.typ.getOrElse(inferredType), funcScopePrefix))(x.pos)

    })

    // Check statements within the main scope
    val newProg = new Prog(newFuncs, checkStatements(inProg.stats, mutable.Map.empty, null, "main-"))(inProg.pos)
    (errors.toList, newProg, symTable)
  }

}
